/// Generated by the Protocol Buffers 3.5.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 4.0.0
/// Source file "vector_tile.proto"
/// Syntax "Proto2"

import Foundation
import ProtocolBuffers


public struct VectorTile { }

public extension VectorTile {
    public struct VectorTileRoot {
        public static let `default` = VectorTileRoot()
        public var extensionRegistry:ExtensionRegistry

        init() {
            extensionRegistry = ExtensionRegistry()
            registerAllExtensions(registry: extensionRegistry)
        }
        public func registerAllExtensions(registry: ExtensionRegistry) {
        }
    }

    final public class Tile : ExtendableMessage {
        public typealias BuilderType = VectorTile.Tile.Builder

        public static func == (lhs: VectorTile.Tile, rhs: VectorTile.Tile) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.layers == rhs.layers)
            fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(otherMessage: rhs, startInclusive:16, endExclusive:8192)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



        //Nested type declaration start

        /// Variant type encoding
        /// The use of values is described in section 4.1 of the specification
        final public class Value : ExtendableMessage {
            public typealias BuilderType = VectorTile.Tile.Value.Builder

            public static func == (lhs: VectorTile.Tile.Value, rhs: VectorTile.Tile.Value) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasStringValue == rhs.hasStringValue) && (!lhs.hasStringValue || lhs.stringValue == rhs.stringValue)
                fieldCheck = fieldCheck && (lhs.hasFloatValue == rhs.hasFloatValue) && (!lhs.hasFloatValue || lhs.floatValue == rhs.floatValue)
                fieldCheck = fieldCheck && (lhs.hasDoubleValue == rhs.hasDoubleValue) && (!lhs.hasDoubleValue || lhs.doubleValue == rhs.doubleValue)
                fieldCheck = fieldCheck && (lhs.hasIntValue == rhs.hasIntValue) && (!lhs.hasIntValue || lhs.intValue == rhs.intValue)
                fieldCheck = fieldCheck && (lhs.hasUintValue == rhs.hasUintValue) && (!lhs.hasUintValue || lhs.uintValue == rhs.uintValue)
                fieldCheck = fieldCheck && (lhs.hasSintValue == rhs.hasSintValue) && (!lhs.hasSintValue || lhs.sintValue == rhs.sintValue)
                fieldCheck = fieldCheck && (lhs.hasBoolValue == rhs.hasBoolValue) && (!lhs.hasBoolValue || lhs.boolValue == rhs.boolValue)
                fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(otherMessage: rhs, startInclusive:8, endExclusive:536870912)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            /// Exactly one of these values must be present in a valid message
            public fileprivate(set) var stringValue:String! = nil
            public fileprivate(set) var hasStringValue:Bool = false

            public fileprivate(set) var floatValue:Float! = nil
            public fileprivate(set) var hasFloatValue:Bool = false

            public fileprivate(set) var doubleValue:Double! = nil
            public fileprivate(set) var hasDoubleValue:Bool = false

            public fileprivate(set) var intValue:Int64! = nil
            public fileprivate(set) var hasIntValue:Bool = false

            public fileprivate(set) var uintValue:UInt64! = nil
            public fileprivate(set) var hasUintValue:Bool = false

            public fileprivate(set) var sintValue:Int64! = nil
            public fileprivate(set) var hasSintValue:Bool = false

            public fileprivate(set) var boolValue:Bool! = nil
            public fileprivate(set) var hasBoolValue:Bool = false

            required public init() {
                super.init()
            }
            override public func isInitialized() throws {
                try extensionsAreInitialized()}
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasStringValue {
                    try codedOutputStream.writeString(fieldNumber: 1, value:stringValue)
                }
                if hasFloatValue {
                    try codedOutputStream.writeFloat(fieldNumber: 2, value:floatValue)
                }
                if hasDoubleValue {
                    try codedOutputStream.writeDouble(fieldNumber: 3, value:doubleValue)
                }
                if hasIntValue {
                    try codedOutputStream.writeInt64(fieldNumber: 4, value:intValue)
                }
                if hasUintValue {
                    try codedOutputStream.writeUInt64(fieldNumber: 5, value:uintValue)
                }
                if hasSintValue {
                    try codedOutputStream.writeSInt64(fieldNumber: 6, value:sintValue)
                }
                if hasBoolValue {
                    try codedOutputStream.writeBool(fieldNumber: 7, value:boolValue)
                }
                try writeExtensionsTo(codedOutputStream: codedOutputStream, startInclusive:8, endExclusive:536870912)
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasStringValue {
                    serialize_size += stringValue.computeStringSize(fieldNumber: 1)
                }
                if hasFloatValue {
                    serialize_size += floatValue.computeFloatSize(fieldNumber: 2)
                }
                if hasDoubleValue {
                    serialize_size += doubleValue.computeDoubleSize(fieldNumber: 3)
                }
                if hasIntValue {
                    serialize_size += intValue.computeInt64Size(fieldNumber: 4)
                }
                if hasUintValue {
                    serialize_size += uintValue.computeUInt64Size(fieldNumber: 5)
                }
                if hasSintValue {
                    serialize_size += sintValue.computeSInt64Size(fieldNumber: 6)
                }
                if hasBoolValue {
                    serialize_size += boolValue.computeBoolSize(fieldNumber: 7)
                }
                serialize_size += extensionsSerializedSize()
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> VectorTile.Tile.Value.Builder {
                return VectorTile.Tile.Value.classBuilder() as! VectorTile.Tile.Value.Builder
            }
            public func getBuilder() -> VectorTile.Tile.Value.Builder {
                return classBuilder() as! VectorTile.Tile.Value.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return VectorTile.Tile.Value.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return VectorTile.Tile.Value.Builder()
            }
            public func toBuilder() throws -> VectorTile.Tile.Value.Builder {
                return try VectorTile.Tile.Value.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:VectorTile.Tile.Value) throws -> VectorTile.Tile.Value.Builder {
                return try VectorTile.Tile.Value.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                try isInitialized()
                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasStringValue {
                    jsonMap["stringValue"] = stringValue
                }
                if hasFloatValue {
                    jsonMap["floatValue"] = Float(floatValue)
                }
                if hasDoubleValue {
                    jsonMap["doubleValue"] = Double(doubleValue)
                }
                if hasIntValue {
                    jsonMap["intValue"] = "\(intValue!)"
                }
                if hasUintValue {
                    jsonMap["uintValue"] = "\(uintValue!)"
                }
                if hasSintValue {
                    jsonMap["sintValue"] = "\(sintValue!)"
                }
                if hasBoolValue {
                    jsonMap["boolValue"] = boolValue
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> VectorTile.Tile.Value {
                return try VectorTile.Tile.Value.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> VectorTile.Tile.Value {
                return try VectorTile.Tile.Value.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasStringValue {
                    output += "\(indent) stringValue: \(stringValue) \n"
                }
                if hasFloatValue {
                    output += "\(indent) floatValue: \(floatValue) \n"
                }
                if hasDoubleValue {
                    output += "\(indent) doubleValue: \(doubleValue) \n"
                }
                if hasIntValue {
                    output += "\(indent) intValue: \(intValue) \n"
                }
                if hasUintValue {
                    output += "\(indent) uintValue: \(uintValue) \n"
                }
                if hasSintValue {
                    output += "\(indent) sintValue: \(sintValue) \n"
                }
                if hasBoolValue {
                    output += "\(indent) boolValue: \(boolValue) \n"
                }
                output += try getExtensionDescription(startInclusive:8, endExclusive:536870912, indent:indent)
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasStringValue {
                        hashCode = (hashCode &* 31) &+ stringValue.hashValue
                    }
                    if hasFloatValue {
                        hashCode = (hashCode &* 31) &+ floatValue.hashValue
                    }
                    if hasDoubleValue {
                        hashCode = (hashCode &* 31) &+ doubleValue.hashValue
                    }
                    if hasIntValue {
                        hashCode = (hashCode &* 31) &+ intValue.hashValue
                    }
                    if hasUintValue {
                        hashCode = (hashCode &* 31) &+ uintValue.hashValue
                    }
                    if hasSintValue {
                        hashCode = (hashCode &* 31) &+ sintValue.hashValue
                    }
                    if hasBoolValue {
                        hashCode = (hashCode &* 31) &+ boolValue.hashValue
                    }
                    hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(startInclusive: 8, endExclusive:536870912))
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "VectorTile.Tile.Value"
            }
            override public func className() -> String {
                return "VectorTile.Tile.Value"
            }
            //Meta information declaration end

            final public class Builder : ExtendableMessageBuilder {
                fileprivate var builderResult:VectorTile.Tile.Value = VectorTile.Tile.Value()
                public func getMessage() -> VectorTile.Tile.Value {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                /// Exactly one of these values must be present in a valid message
                public var stringValue:String {
                    get {
                        return builderResult.stringValue
                    }
                    set (value) {
                        builderResult.hasStringValue = true
                        builderResult.stringValue = value
                    }
                }
                public var hasStringValue:Bool {
                    get {
                        return builderResult.hasStringValue
                    }
                }
                @discardableResult
                public func setStringValue(_ value:String) -> VectorTile.Tile.Value.Builder {
                    self.stringValue = value
                    return self
                }
                @discardableResult
                public func clearStringValue() -> VectorTile.Tile.Value.Builder{
                    builderResult.hasStringValue = false
                    builderResult.stringValue = nil
                    return self
                }
                public var floatValue:Float {
                    get {
                        return builderResult.floatValue
                    }
                    set (value) {
                        builderResult.hasFloatValue = true
                        builderResult.floatValue = value
                    }
                }
                public var hasFloatValue:Bool {
                    get {
                        return builderResult.hasFloatValue
                    }
                }
                @discardableResult
                public func setFloatValue(_ value:Float) -> VectorTile.Tile.Value.Builder {
                    self.floatValue = value
                    return self
                }
                @discardableResult
                public func clearFloatValue() -> VectorTile.Tile.Value.Builder{
                    builderResult.hasFloatValue = false
                    builderResult.floatValue = nil
                    return self
                }
                public var doubleValue:Double {
                    get {
                        return builderResult.doubleValue
                    }
                    set (value) {
                        builderResult.hasDoubleValue = true
                        builderResult.doubleValue = value
                    }
                }
                public var hasDoubleValue:Bool {
                    get {
                        return builderResult.hasDoubleValue
                    }
                }
                @discardableResult
                public func setDoubleValue(_ value:Double) -> VectorTile.Tile.Value.Builder {
                    self.doubleValue = value
                    return self
                }
                @discardableResult
                public func clearDoubleValue() -> VectorTile.Tile.Value.Builder{
                    builderResult.hasDoubleValue = false
                    builderResult.doubleValue = nil
                    return self
                }
                public var intValue:Int64 {
                    get {
                        return builderResult.intValue
                    }
                    set (value) {
                        builderResult.hasIntValue = true
                        builderResult.intValue = value
                    }
                }
                public var hasIntValue:Bool {
                    get {
                        return builderResult.hasIntValue
                    }
                }
                @discardableResult
                public func setIntValue(_ value:Int64) -> VectorTile.Tile.Value.Builder {
                    self.intValue = value
                    return self
                }
                @discardableResult
                public func clearIntValue() -> VectorTile.Tile.Value.Builder{
                    builderResult.hasIntValue = false
                    builderResult.intValue = nil
                    return self
                }
                public var uintValue:UInt64 {
                    get {
                        return builderResult.uintValue
                    }
                    set (value) {
                        builderResult.hasUintValue = true
                        builderResult.uintValue = value
                    }
                }
                public var hasUintValue:Bool {
                    get {
                        return builderResult.hasUintValue
                    }
                }
                @discardableResult
                public func setUintValue(_ value:UInt64) -> VectorTile.Tile.Value.Builder {
                    self.uintValue = value
                    return self
                }
                @discardableResult
                public func clearUintValue() -> VectorTile.Tile.Value.Builder{
                    builderResult.hasUintValue = false
                    builderResult.uintValue = nil
                    return self
                }
                public var sintValue:Int64 {
                    get {
                        return builderResult.sintValue
                    }
                    set (value) {
                        builderResult.hasSintValue = true
                        builderResult.sintValue = value
                    }
                }
                public var hasSintValue:Bool {
                    get {
                        return builderResult.hasSintValue
                    }
                }
                @discardableResult
                public func setSintValue(_ value:Int64) -> VectorTile.Tile.Value.Builder {
                    self.sintValue = value
                    return self
                }
                @discardableResult
                public func clearSintValue() -> VectorTile.Tile.Value.Builder{
                    builderResult.hasSintValue = false
                    builderResult.sintValue = nil
                    return self
                }
                public var boolValue:Bool {
                    get {
                        return builderResult.boolValue
                    }
                    set (value) {
                        builderResult.hasBoolValue = true
                        builderResult.boolValue = value
                    }
                }
                public var hasBoolValue:Bool {
                    get {
                        return builderResult.hasBoolValue
                    }
                }
                @discardableResult
                public func setBoolValue(_ value:Bool) -> VectorTile.Tile.Value.Builder {
                    self.boolValue = value
                    return self
                }
                @discardableResult
                public func clearBoolValue() -> VectorTile.Tile.Value.Builder{
                    builderResult.hasBoolValue = false
                    builderResult.boolValue = nil
                    return self
                }
                override public var internalGetResult:ExtendableMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> VectorTile.Tile.Value.Builder {
                    builderResult = VectorTile.Tile.Value()
                    return self
                }
                override public func clone() throws -> VectorTile.Tile.Value.Builder {
                    return try VectorTile.Tile.Value.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> VectorTile.Tile.Value {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> VectorTile.Tile.Value {
                    let returnMe:VectorTile.Tile.Value = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:VectorTile.Tile.Value) throws -> VectorTile.Tile.Value.Builder {
                    if other == VectorTile.Tile.Value() {
                        return self
                    }
                    if other.hasStringValue {
                        stringValue = other.stringValue
                    }
                    if other.hasFloatValue {
                        floatValue = other.floatValue
                    }
                    if other.hasDoubleValue {
                        doubleValue = other.doubleValue
                    }
                    if other.hasIntValue {
                        intValue = other.intValue
                    }
                    if other.hasUintValue {
                        uintValue = other.uintValue
                    }
                    if other.hasSintValue {
                        sintValue = other.sintValue
                    }
                    if other.hasBoolValue {
                        boolValue = other.boolValue
                    }
                    try mergeExtensionFields(other: other)
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> VectorTile.Tile.Value.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> VectorTile.Tile.Value.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 10:
                            stringValue = try codedInputStream.readString()

                        case 21:
                            floatValue = try codedInputStream.readFloat()

                        case 25:
                            doubleValue = try codedInputStream.readDouble()

                        case 32:
                            intValue = try codedInputStream.readInt64()

                        case 40:
                            uintValue = try codedInputStream.readUInt64()

                        case 48:
                            sintValue = try codedInputStream.readSInt64()

                        case 56:
                            boolValue = try codedInputStream.readBool()

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> VectorTile.Tile.Value.Builder {
                    let resultDecodedBuilder = VectorTile.Tile.Value.Builder()
                    if let jsonValueStringValue = jsonMap["stringValue"] as? String {
                        resultDecodedBuilder.stringValue = jsonValueStringValue
                    }
                    if let jsonValueFloatValue = jsonMap["floatValue"] as? Float {
                        resultDecodedBuilder.floatValue = Float(jsonValueFloatValue)
                    } else if let jsonValueFloatValue = jsonMap["floatValue"] as? String {
                        resultDecodedBuilder.floatValue = Float(jsonValueFloatValue)!
                    }
                    if let jsonValueDoubleValue = jsonMap["doubleValue"] as? Double {
                        resultDecodedBuilder.doubleValue = Double(jsonValueDoubleValue)
                    } else if let jsonValueDoubleValue = jsonMap["doubleValue"] as? String {
                        resultDecodedBuilder.doubleValue = Double(jsonValueDoubleValue)!
                    }
                    if let jsonValueIntValue = jsonMap["intValue"] as? String {
                        resultDecodedBuilder.intValue = Int64(jsonValueIntValue)!
                    } else if let jsonValueIntValue = jsonMap["intValue"] as? Int {
                        resultDecodedBuilder.intValue = Int64(jsonValueIntValue)
                    }
                    if let jsonValueUintValue = jsonMap["uintValue"] as? String {
                        resultDecodedBuilder.uintValue = UInt64(jsonValueUintValue)!
                    } else if let jsonValueUintValue = jsonMap["uintValue"] as? UInt {
                        resultDecodedBuilder.uintValue = UInt64(jsonValueUintValue)
                    }
                    if let jsonValueSintValue = jsonMap["sintValue"] as? String {
                        resultDecodedBuilder.sintValue = Int64(jsonValueSintValue)!
                    } else if let jsonValueSintValue = jsonMap["sintValue"] as? Int {
                        resultDecodedBuilder.sintValue = Int64(jsonValueSintValue)
                    }
                    if let jsonValueBoolValue = jsonMap["boolValue"] as? Bool {
                        resultDecodedBuilder.boolValue = jsonValueBoolValue
                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> VectorTile.Tile.Value.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try VectorTile.Tile.Value.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end



        //Nested type declaration start

        /// Features are described in section 4.2 of the specification
        final public class Feature : GeneratedMessage {
            public typealias BuilderType = VectorTile.Tile.Feature.Builder

            public static func == (lhs: VectorTile.Tile.Feature, rhs: VectorTile.Tile.Feature) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasId == rhs.hasId) && (!lhs.hasId || lhs.id == rhs.id)
                fieldCheck = fieldCheck && (lhs.tags == rhs.tags)
                fieldCheck = fieldCheck && (lhs.hasType == rhs.hasType) && (!lhs.hasType || lhs.type == rhs.type)
                fieldCheck = fieldCheck && (lhs.geometry == rhs.geometry)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            public fileprivate(set) var id:UInt64! = UInt64(0)
            public fileprivate(set) var hasId:Bool = false

            /// Tags of this feature are encoded as repeated pairs of
            /// integers.
            /// A detailed description of tags is located in sections
            /// 4.2 and 4.4 of the specification
            public fileprivate(set) var tags:Array<UInt32> = Array<UInt32>()
            private var tagsMemoizedSerializedSize:Int32 = -1
            public fileprivate(set) var type:VectorTile.Tile.GeomType = VectorTile.Tile.GeomType.unknown
            public fileprivate(set) var hasType:Bool = false
            /// Contains a stream of commands and parameters (vertices).
            /// A detailed description on geometry encoding is located in
            /// section 4.3 of the specification.
            public fileprivate(set) var geometry:Array<UInt32> = Array<UInt32>()
            private var geometryMemoizedSerializedSize:Int32 = -1
            required public init() {
                super.init()
            }
            override public func isInitialized() throws {
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasId {
                    try codedOutputStream.writeUInt64(fieldNumber: 1, value:id)
                }
                if !tags.isEmpty {
                    try codedOutputStream.writeRawVarint32(value: 18)
                    try codedOutputStream.writeRawVarint32(value: tagsMemoizedSerializedSize)
                    for oneValuetags in tags {
                        try codedOutputStream.writeUInt32NoTag(value: oneValuetags)
                    }
                }
                if hasType {
                    try codedOutputStream.writeEnum(fieldNumber: 3, value:type.rawValue)
                }
                if !geometry.isEmpty {
                    try codedOutputStream.writeRawVarint32(value: 34)
                    try codedOutputStream.writeRawVarint32(value: geometryMemoizedSerializedSize)
                    for oneValuegeometry in geometry {
                        try codedOutputStream.writeUInt32NoTag(value: oneValuegeometry)
                    }
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasId {
                    serialize_size += id.computeUInt64Size(fieldNumber: 1)
                }
                var dataSizeTags:Int32 = 0
                for oneValuetags in tags {
                    dataSizeTags += oneValuetags.computeUInt32SizeNoTag()
                }
                serialize_size += dataSizeTags
                if !tags.isEmpty {
                    serialize_size += 1
                    serialize_size += dataSizeTags.computeInt32SizeNoTag()
                }
                tagsMemoizedSerializedSize = dataSizeTags
                if (hasType) {
                    serialize_size += type.rawValue.computeEnumSize(fieldNumber: 3)
                }
                var dataSizeGeometry:Int32 = 0
                for oneValuegeometry in geometry {
                    dataSizeGeometry += oneValuegeometry.computeUInt32SizeNoTag()
                }
                serialize_size += dataSizeGeometry
                if !geometry.isEmpty {
                    serialize_size += 1
                    serialize_size += dataSizeGeometry.computeInt32SizeNoTag()
                }
                geometryMemoizedSerializedSize = dataSizeGeometry
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> VectorTile.Tile.Feature.Builder {
                return VectorTile.Tile.Feature.classBuilder() as! VectorTile.Tile.Feature.Builder
            }
            public func getBuilder() -> VectorTile.Tile.Feature.Builder {
                return classBuilder() as! VectorTile.Tile.Feature.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return VectorTile.Tile.Feature.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return VectorTile.Tile.Feature.Builder()
            }
            public func toBuilder() throws -> VectorTile.Tile.Feature.Builder {
                return try VectorTile.Tile.Feature.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:VectorTile.Tile.Feature) throws -> VectorTile.Tile.Feature.Builder {
                return try VectorTile.Tile.Feature.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                try isInitialized()
                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasId {
                    jsonMap["id"] = "\(id!)"
                }
                if !tags.isEmpty {
                    var jsonArrayTags:Array<UInt> = []
                    for oneValueTags in tags {
                        jsonArrayTags.append(UInt(oneValueTags))
                    }
                    jsonMap["tags"] = jsonArrayTags
                }
                if hasType {
                    jsonMap["type"] = type.toString()
                }
                if !geometry.isEmpty {
                    var jsonArrayGeometry:Array<UInt> = []
                    for oneValueGeometry in geometry {
                        jsonArrayGeometry.append(UInt(oneValueGeometry))
                    }
                    jsonMap["geometry"] = jsonArrayGeometry
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> VectorTile.Tile.Feature {
                return try VectorTile.Tile.Feature.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> VectorTile.Tile.Feature {
                return try VectorTile.Tile.Feature.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasId {
                    output += "\(indent) id: \(id) \n"
                }
                var tagsElementIndex:Int = 0
                for oneValueTags in tags  {
                    output += "\(indent) tags[\(tagsElementIndex)]: \(oneValueTags)\n"
                    tagsElementIndex += 1
                }
                if (hasType) {
                    output += "\(indent) type: \(type.description)\n"
                }
                var geometryElementIndex:Int = 0
                for oneValueGeometry in geometry  {
                    output += "\(indent) geometry[\(geometryElementIndex)]: \(oneValueGeometry)\n"
                    geometryElementIndex += 1
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasId {
                        hashCode = (hashCode &* 31) &+ id.hashValue
                    }
                    for oneValueTags in tags {
                        hashCode = (hashCode &* 31) &+ oneValueTags.hashValue
                    }
                    if hasType {
                         hashCode = (hashCode &* 31) &+ type.hashValue
                    }
                    for oneValueGeometry in geometry {
                        hashCode = (hashCode &* 31) &+ oneValueGeometry.hashValue
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "VectorTile.Tile.Feature"
            }
            override public func className() -> String {
                return "VectorTile.Tile.Feature"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:VectorTile.Tile.Feature = VectorTile.Tile.Feature()
                public func getMessage() -> VectorTile.Tile.Feature {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                public var id:UInt64 {
                    get {
                        return builderResult.id
                    }
                    set (value) {
                        builderResult.hasId = true
                        builderResult.id = value
                    }
                }
                public var hasId:Bool {
                    get {
                        return builderResult.hasId
                    }
                }
                @discardableResult
                public func setId(_ value:UInt64) -> VectorTile.Tile.Feature.Builder {
                    self.id = value
                    return self
                }
                @discardableResult
                public func clearId() -> VectorTile.Tile.Feature.Builder{
                    builderResult.hasId = false
                    builderResult.id = UInt64(0)
                    return self
                }
                /// Tags of this feature are encoded as repeated pairs of
                /// integers.
                /// A detailed description of tags is located in sections
                /// 4.2 and 4.4 of the specification
                public var tags:Array<UInt32> {
                    get {
                        return builderResult.tags
                    }
                    set (array) {
                        builderResult.tags = array
                    }
                }
                @discardableResult
                public func setTags(_ value:Array<UInt32>) -> VectorTile.Tile.Feature.Builder {
                    self.tags = value
                    return self
                }
                @discardableResult
                public func clearTags() -> VectorTile.Tile.Feature.Builder {
                    builderResult.tags.removeAll(keepingCapacity: false)
                    return self
                }
                /// The type of geometry stored in this feature.
                    public var type:VectorTile.Tile.GeomType {
                        get {
                            return builderResult.type
                        }
                        set (value) {
                            builderResult.hasType = true
                            builderResult.type = value
                        }
                    }
                    public var hasType:Bool{
                        get {
                            return builderResult.hasType
                        }
                    }
                @discardableResult
                    public func setType(_ value:VectorTile.Tile.GeomType) -> VectorTile.Tile.Feature.Builder {
                      self.type = value
                      return self
                    }
                @discardableResult
                    public func clearType() -> VectorTile.Tile.Feature.Builder {
                       builderResult.hasType = false
                       builderResult.type = .unknown
                       return self
                    }
                /// Contains a stream of commands and parameters (vertices).
                /// A detailed description on geometry encoding is located in
                /// section 4.3 of the specification.
                public var geometry:Array<UInt32> {
                    get {
                        return builderResult.geometry
                    }
                    set (array) {
                        builderResult.geometry = array
                    }
                }
                @discardableResult
                public func setGeometry(_ value:Array<UInt32>) -> VectorTile.Tile.Feature.Builder {
                    self.geometry = value
                    return self
                }
                @discardableResult
                public func clearGeometry() -> VectorTile.Tile.Feature.Builder {
                    builderResult.geometry.removeAll(keepingCapacity: false)
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> VectorTile.Tile.Feature.Builder {
                    builderResult = VectorTile.Tile.Feature()
                    return self
                }
                override public func clone() throws -> VectorTile.Tile.Feature.Builder {
                    return try VectorTile.Tile.Feature.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> VectorTile.Tile.Feature {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> VectorTile.Tile.Feature {
                    let returnMe:VectorTile.Tile.Feature = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:VectorTile.Tile.Feature) throws -> VectorTile.Tile.Feature.Builder {
                    if other == VectorTile.Tile.Feature() {
                        return self
                    }
                    if other.hasId {
                        id = other.id
                    }
                    if !other.tags.isEmpty {
                        builderResult.tags += other.tags
                    }
                    if other.hasType {
                        type = other.type
                    }
                    if !other.geometry.isEmpty {
                        builderResult.geometry += other.geometry
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> VectorTile.Tile.Feature.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> VectorTile.Tile.Feature.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 8:
                            id = try codedInputStream.readUInt64()

                        case 18:
                            let length = Int(try codedInputStream.readRawVarint32())
                            let limit = try codedInputStream.pushLimit(byteLimit: length)
                            while (codedInputStream.bytesUntilLimit() > 0) {
                                builderResult.tags.append(try codedInputStream.readUInt32())
                            }
                            codedInputStream.popLimit(oldLimit: limit)

                        case 24:
                            let valueInttype = try codedInputStream.readEnum()
                            if let enumstype = VectorTile.Tile.GeomType(rawValue:valueInttype){
                                type = enumstype
                            } else {
                                try unknownFieldsBuilder.mergeVarintField(fieldNumber: 3, value:Int64(valueInttype))
                            }

                        case 34:
                            let length = Int(try codedInputStream.readRawVarint32())
                            let limit = try codedInputStream.pushLimit(byteLimit: length)
                            while (codedInputStream.bytesUntilLimit() > 0) {
                                builderResult.geometry.append(try codedInputStream.readUInt32())
                            }
                            codedInputStream.popLimit(oldLimit: limit)

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> VectorTile.Tile.Feature.Builder {
                    let resultDecodedBuilder = VectorTile.Tile.Feature.Builder()
                    if let jsonValueId = jsonMap["id"] as? String {
                        resultDecodedBuilder.id = UInt64(jsonValueId)!
                    } else if let jsonValueId = jsonMap["id"] as? UInt {
                        resultDecodedBuilder.id = UInt64(jsonValueId)
                    }
                    if let jsonValueTags = jsonMap["tags"] as? Array<UInt> {
                        var jsonArrayTags:Array<UInt32> = []
                        for oneValueTags in jsonValueTags {
                            jsonArrayTags.append(UInt32(oneValueTags))
                        }
                        resultDecodedBuilder.tags = jsonArrayTags
                    }
                    if let jsonValueType = jsonMap["type"] as? String {
                        resultDecodedBuilder.type = try VectorTile.Tile.GeomType.fromString(jsonValueType)
                    }
                    if let jsonValueGeometry = jsonMap["geometry"] as? Array<UInt> {
                        var jsonArrayGeometry:Array<UInt32> = []
                        for oneValueGeometry in jsonValueGeometry {
                            jsonArrayGeometry.append(UInt32(oneValueGeometry))
                        }
                        resultDecodedBuilder.geometry = jsonArrayGeometry
                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> VectorTile.Tile.Feature.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try VectorTile.Tile.Feature.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end



        //Nested type declaration start

        /// Layers are described in section 4.1 of the specification
        final public class Layer : ExtendableMessage {
            public typealias BuilderType = VectorTile.Tile.Layer.Builder

            public static func == (lhs: VectorTile.Tile.Layer, rhs: VectorTile.Tile.Layer) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
                fieldCheck = fieldCheck && (lhs.features == rhs.features)
                fieldCheck = fieldCheck && (lhs.keys == rhs.keys)
                fieldCheck = fieldCheck && (lhs.values == rhs.values)
                fieldCheck = fieldCheck && (lhs.hasExtent == rhs.hasExtent) && (!lhs.hasExtent || lhs.extent == rhs.extent)
                fieldCheck = fieldCheck && (lhs.hasVersion == rhs.hasVersion) && (!lhs.hasVersion || lhs.version == rhs.version)
                fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(otherMessage: rhs, startInclusive:16, endExclusive:536870912)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            /// Any compliant implementation must first read the version
            /// number encoded in this message and choose the correct
            /// implementation for this version number before proceeding to
            /// decode other parts of this message.
            public fileprivate(set) var version:UInt32! = UInt32(1)
            public fileprivate(set) var hasVersion:Bool = false

            public fileprivate(set) var name:String! = nil
            public fileprivate(set) var hasName:Bool = false

            public fileprivate(set) var features:Array<VectorTile.Tile.Feature>  = Array<VectorTile.Tile.Feature>()
            /// Dictionary encoding for keys
            public fileprivate(set) var keys:Array<String> = Array<String>()
            public fileprivate(set) var values:Array<VectorTile.Tile.Value>  = Array<VectorTile.Tile.Value>()
            /// Although this is an "optional" field it is required by the specification.
            /// See https://github.com/mapbox/vector-tile-spec/issues/47
            public fileprivate(set) var extent:UInt32! = UInt32(4096)
            public fileprivate(set) var hasExtent:Bool = false

            required public init() {
                super.init()
            }
            override public func isInitialized() throws {
                if !hasVersion {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message \(VectorTile.Tile.Layer.self): field \"version\" mark required")
                }
                if !hasName {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message \(VectorTile.Tile.Layer.self): field \"name\" mark required")
                }
                for oneElementValues in values {
                    try oneElementValues.isInitialized()
                }
                try extensionsAreInitialized()}
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasName {
                    try codedOutputStream.writeString(fieldNumber: 1, value:name)
                }
                for oneElementFeatures in features {
                      try codedOutputStream.writeMessage(fieldNumber: 2, value:oneElementFeatures)
                }
                if !keys.isEmpty {
                    for oneValuekeys in keys {
                        try codedOutputStream.writeString(fieldNumber: 3, value:oneValuekeys)
                    }
                }
                for oneElementValues in values {
                      try codedOutputStream.writeMessage(fieldNumber: 4, value:oneElementValues)
                }
                if hasExtent {
                    try codedOutputStream.writeUInt32(fieldNumber: 5, value:extent)
                }
                if hasVersion {
                    try codedOutputStream.writeUInt32(fieldNumber: 15, value:version)
                }
                try writeExtensionsTo(codedOutputStream: codedOutputStream, startInclusive:16, endExclusive:536870912)
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasName {
                    serialize_size += name.computeStringSize(fieldNumber: 1)
                }
                for oneElementFeatures in features {
                    serialize_size += oneElementFeatures.computeMessageSize(fieldNumber: 2)
                }
                var dataSizeKeys:Int32 = 0
                for oneValuekeys in keys {
                    dataSizeKeys += oneValuekeys.computeStringSizeNoTag()
                }
                serialize_size += dataSizeKeys
                serialize_size += 1 * Int32(keys.count)
                for oneElementValues in values {
                    serialize_size += oneElementValues.computeMessageSize(fieldNumber: 4)
                }
                if hasExtent {
                    serialize_size += extent.computeUInt32Size(fieldNumber: 5)
                }
                if hasVersion {
                    serialize_size += version.computeUInt32Size(fieldNumber: 15)
                }
                serialize_size += extensionsSerializedSize()
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> VectorTile.Tile.Layer.Builder {
                return VectorTile.Tile.Layer.classBuilder() as! VectorTile.Tile.Layer.Builder
            }
            public func getBuilder() -> VectorTile.Tile.Layer.Builder {
                return classBuilder() as! VectorTile.Tile.Layer.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return VectorTile.Tile.Layer.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return VectorTile.Tile.Layer.Builder()
            }
            public func toBuilder() throws -> VectorTile.Tile.Layer.Builder {
                return try VectorTile.Tile.Layer.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:VectorTile.Tile.Layer) throws -> VectorTile.Tile.Layer.Builder {
                return try VectorTile.Tile.Layer.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                try isInitialized()
                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasVersion {
                    jsonMap["version"] = UInt(version)
                }
                if hasName {
                    jsonMap["name"] = name
                }
                if !features.isEmpty {
                    var jsonArrayFeatures:Array<Dictionary<String,Any>> = []
                    for oneValueFeatures in features {
                        let ecodedMessageFeatures = try oneValueFeatures.encode()
                        jsonArrayFeatures.append(ecodedMessageFeatures)
                    }
                    jsonMap["features"] = jsonArrayFeatures
                }
                if !keys.isEmpty {
                    var jsonArrayKeys:Array<String> = []
                    for oneValueKeys in keys {
                        jsonArrayKeys.append(oneValueKeys)
                    }
                    jsonMap["keys"] = jsonArrayKeys
                }
                if !values.isEmpty {
                    var jsonArrayValues:Array<Dictionary<String,Any>> = []
                    for oneValueValues in values {
                        let ecodedMessageValues = try oneValueValues.encode()
                        jsonArrayValues.append(ecodedMessageValues)
                    }
                    jsonMap["values"] = jsonArrayValues
                }
                if hasExtent {
                    jsonMap["extent"] = UInt(extent)
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> VectorTile.Tile.Layer {
                return try VectorTile.Tile.Layer.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> VectorTile.Tile.Layer {
                return try VectorTile.Tile.Layer.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasName {
                    output += "\(indent) name: \(name) \n"
                }
                var featuresElementIndex:Int = 0
                for oneElementFeatures in features {
                    output += "\(indent) features[\(featuresElementIndex)] {\n"
                    output += try oneElementFeatures.getDescription(indent: "\(indent)  ")
                    output += "\(indent)}\n"
                    featuresElementIndex += 1
                }
                var keysElementIndex:Int = 0
                for oneValueKeys in keys  {
                    output += "\(indent) keys[\(keysElementIndex)]: \(oneValueKeys)\n"
                    keysElementIndex += 1
                }
                var valuesElementIndex:Int = 0
                for oneElementValues in values {
                    output += "\(indent) values[\(valuesElementIndex)] {\n"
                    output += try oneElementValues.getDescription(indent: "\(indent)  ")
                    output += "\(indent)}\n"
                    valuesElementIndex += 1
                }
                if hasExtent {
                    output += "\(indent) extent: \(extent) \n"
                }
                if hasVersion {
                    output += "\(indent) version: \(version) \n"
                }
                output += try getExtensionDescription(startInclusive:16, endExclusive:536870912, indent:indent)
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasName {
                        hashCode = (hashCode &* 31) &+ name.hashValue
                    }
                    for oneElementFeatures in features {
                        hashCode = (hashCode &* 31) &+ oneElementFeatures.hashValue
                    }
                    for oneValueKeys in keys {
                        hashCode = (hashCode &* 31) &+ oneValueKeys.hashValue
                    }
                    for oneElementValues in values {
                        hashCode = (hashCode &* 31) &+ oneElementValues.hashValue
                    }
                    if hasExtent {
                        hashCode = (hashCode &* 31) &+ extent.hashValue
                    }
                    if hasVersion {
                        hashCode = (hashCode &* 31) &+ version.hashValue
                    }
                    hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(startInclusive: 16, endExclusive:536870912))
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "VectorTile.Tile.Layer"
            }
            override public func className() -> String {
                return "VectorTile.Tile.Layer"
            }
            //Meta information declaration end

            final public class Builder : ExtendableMessageBuilder {
                fileprivate var builderResult:VectorTile.Tile.Layer = VectorTile.Tile.Layer()
                public func getMessage() -> VectorTile.Tile.Layer {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                /// Any compliant implementation must first read the version
                /// number encoded in this message and choose the correct
                /// implementation for this version number before proceeding to
                /// decode other parts of this message.
                public var version:UInt32 {
                    get {
                        return builderResult.version
                    }
                    set (value) {
                        builderResult.hasVersion = true
                        builderResult.version = value
                    }
                }
                public var hasVersion:Bool {
                    get {
                        return builderResult.hasVersion
                    }
                }
                @discardableResult
                public func setVersion(_ value:UInt32) -> VectorTile.Tile.Layer.Builder {
                    self.version = value
                    return self
                }
                @discardableResult
                public func clearVersion() -> VectorTile.Tile.Layer.Builder{
                    builderResult.hasVersion = false
                    builderResult.version = UInt32(1)
                    return self
                }
                public var name:String {
                    get {
                        return builderResult.name
                    }
                    set (value) {
                        builderResult.hasName = true
                        builderResult.name = value
                    }
                }
                public var hasName:Bool {
                    get {
                        return builderResult.hasName
                    }
                }
                @discardableResult
                public func setName(_ value:String) -> VectorTile.Tile.Layer.Builder {
                    self.name = value
                    return self
                }
                @discardableResult
                public func clearName() -> VectorTile.Tile.Layer.Builder{
                    builderResult.hasName = false
                    builderResult.name = nil
                    return self
                }
                /// The actual features in this tile.
                public var features:Array<VectorTile.Tile.Feature> {
                    get {
                        return builderResult.features
                    }
                    set (value) {
                        builderResult.features = value
                    }
                }
                @discardableResult
                public func setFeatures(_ value:Array<VectorTile.Tile.Feature>) -> VectorTile.Tile.Layer.Builder {
                    self.features = value
                    return self
                }
                @discardableResult
                public func clearFeatures() -> VectorTile.Tile.Layer.Builder {
                    builderResult.features.removeAll(keepingCapacity: false)
                    return self
                }
                /// Dictionary encoding for keys
                public var keys:Array<String> {
                    get {
                        return builderResult.keys
                    }
                    set (array) {
                        builderResult.keys = array
                    }
                }
                @discardableResult
                public func setKeys(_ value:Array<String>) -> VectorTile.Tile.Layer.Builder {
                    self.keys = value
                    return self
                }
                @discardableResult
                public func clearKeys() -> VectorTile.Tile.Layer.Builder {
                    builderResult.keys.removeAll(keepingCapacity: false)
                    return self
                }
                /// Dictionary encoding for values
                public var values:Array<VectorTile.Tile.Value> {
                    get {
                        return builderResult.values
                    }
                    set (value) {
                        builderResult.values = value
                    }
                }
                @discardableResult
                public func setValues(_ value:Array<VectorTile.Tile.Value>) -> VectorTile.Tile.Layer.Builder {
                    self.values = value
                    return self
                }
                @discardableResult
                public func clearValues() -> VectorTile.Tile.Layer.Builder {
                    builderResult.values.removeAll(keepingCapacity: false)
                    return self
                }
                /// Although this is an "optional" field it is required by the specification.
                /// See https://github.com/mapbox/vector-tile-spec/issues/47
                public var extent:UInt32 {
                    get {
                        return builderResult.extent
                    }
                    set (value) {
                        builderResult.hasExtent = true
                        builderResult.extent = value
                    }
                }
                public var hasExtent:Bool {
                    get {
                        return builderResult.hasExtent
                    }
                }
                @discardableResult
                public func setExtent(_ value:UInt32) -> VectorTile.Tile.Layer.Builder {
                    self.extent = value
                    return self
                }
                @discardableResult
                public func clearExtent() -> VectorTile.Tile.Layer.Builder{
                    builderResult.hasExtent = false
                    builderResult.extent = UInt32(4096)
                    return self
                }
                override public var internalGetResult:ExtendableMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> VectorTile.Tile.Layer.Builder {
                    builderResult = VectorTile.Tile.Layer()
                    return self
                }
                override public func clone() throws -> VectorTile.Tile.Layer.Builder {
                    return try VectorTile.Tile.Layer.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> VectorTile.Tile.Layer {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> VectorTile.Tile.Layer {
                    let returnMe:VectorTile.Tile.Layer = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:VectorTile.Tile.Layer) throws -> VectorTile.Tile.Layer.Builder {
                    if other == VectorTile.Tile.Layer() {
                        return self
                    }
                    if other.hasVersion {
                        version = other.version
                    }
                    if other.hasName {
                        name = other.name
                    }
                    if !other.features.isEmpty  {
                         builderResult.features += other.features
                    }
                    if !other.keys.isEmpty {
                        builderResult.keys += other.keys
                    }
                    if !other.values.isEmpty  {
                         builderResult.values += other.values
                    }
                    if other.hasExtent {
                        extent = other.extent
                    }
                    try mergeExtensionFields(other: other)
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> VectorTile.Tile.Layer.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> VectorTile.Tile.Layer.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 10:
                            name = try codedInputStream.readString()

                        case 18:
                            let subBuilder = VectorTile.Tile.Feature.Builder()
                            try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                            features.append(subBuilder.buildPartial())

                        case 26:
                            keys += [try codedInputStream.readString()]

                        case 34:
                            let subBuilder = VectorTile.Tile.Value.Builder()
                            try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                            values.append(subBuilder.buildPartial())

                        case 40:
                            extent = try codedInputStream.readUInt32()

                        case 120:
                            version = try codedInputStream.readUInt32()

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> VectorTile.Tile.Layer.Builder {
                    let resultDecodedBuilder = VectorTile.Tile.Layer.Builder()
                    if let jsonValueVersion = jsonMap["version"] as? UInt {
                        resultDecodedBuilder.version = UInt32(jsonValueVersion)
                    } else if let jsonValueVersion = jsonMap["version"] as? String {
                        resultDecodedBuilder.version = UInt32(jsonValueVersion)!
                    }
                    if let jsonValueName = jsonMap["name"] as? String {
                        resultDecodedBuilder.name = jsonValueName
                    }
                    if let jsonValueFeatures = jsonMap["features"] as? Array<Dictionary<String,Any>> {
                        var jsonArrayFeatures:Array<VectorTile.Tile.Feature> = []
                        for oneValueFeatures in jsonValueFeatures {
                            let messageFromStringFeatures = try VectorTile.Tile.Feature.Builder.decodeToBuilder(jsonMap:oneValueFeatures).build()

                            jsonArrayFeatures.append(messageFromStringFeatures)
                        }
                        resultDecodedBuilder.features = jsonArrayFeatures
                    }
                    if let jsonValueKeys = jsonMap["keys"] as? Array<String> {
                        var jsonArrayKeys:Array<String> = []
                        for oneValueKeys in jsonValueKeys {
                            jsonArrayKeys.append(oneValueKeys)
                        }
                        resultDecodedBuilder.keys = jsonArrayKeys
                    }
                    if let jsonValueValues = jsonMap["values"] as? Array<Dictionary<String,Any>> {
                        var jsonArrayValues:Array<VectorTile.Tile.Value> = []
                        for oneValueValues in jsonValueValues {
                            let messageFromStringValues = try VectorTile.Tile.Value.Builder.decodeToBuilder(jsonMap:oneValueValues).build()

                            jsonArrayValues.append(messageFromStringValues)
                        }
                        resultDecodedBuilder.values = jsonArrayValues
                    }
                    if let jsonValueExtent = jsonMap["extent"] as? UInt {
                        resultDecodedBuilder.extent = UInt32(jsonValueExtent)
                    } else if let jsonValueExtent = jsonMap["extent"] as? String {
                        resultDecodedBuilder.extent = UInt32(jsonValueExtent)!
                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> VectorTile.Tile.Layer.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try VectorTile.Tile.Layer.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end



            //Enum type declaration start 

            /// GeomType is described in section 4.3.4 of the specification
            public enum GeomType:Int32, GeneratedEnum {
                case unknown = 0
                case point = 1
                case linestring = 2
                case polygon = 3
                public func toString() -> String {
                    switch self {
                    case .unknown: return "UNKNOWN"
                    case .point: return "POINT"
                    case .linestring: return "LINESTRING"
                    case .polygon: return "POLYGON"
                    }
                }
                public static func fromString(_ str:String) throws -> VectorTile.Tile.GeomType {
                    switch str {
                    case "UNKNOWN":    return .unknown
                    case "POINT":    return .point
                    case "LINESTRING":    return .linestring
                    case "POLYGON":    return .polygon
                    default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion failed.")
                    }
                }
                public var debugDescription:String { return getDescription() }
                public var description:String { return getDescription() }
                private func getDescription() -> String { 
                    switch self {
                    case .unknown: return ".unknown"
                    case .point: return ".point"
                    case .linestring: return ".linestring"
                    case .polygon: return ".polygon"
                    }
                }
                public var hashValue:Int {
                    return self.rawValue.hashValue
                }
                public static func ==(lhs:GeomType, rhs:GeomType) -> Bool {
                    return lhs.hashValue == rhs.hashValue
                }
            }

            //Enum type declaration end 

        public fileprivate(set) var layers:Array<VectorTile.Tile.Layer>  = Array<VectorTile.Tile.Layer>()
        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
            for oneElementLayers in layers {
                try oneElementLayers.isInitialized()
            }
            try extensionsAreInitialized()}
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementLayers in layers {
                  try codedOutputStream.writeMessage(fieldNumber: 3, value:oneElementLayers)
            }
            try writeExtensionsTo(codedOutputStream: codedOutputStream, startInclusive:16, endExclusive:8192)
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementLayers in layers {
                serialize_size += oneElementLayers.computeMessageSize(fieldNumber: 3)
            }
            serialize_size += extensionsSerializedSize()
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> VectorTile.Tile.Builder {
            return VectorTile.Tile.classBuilder() as! VectorTile.Tile.Builder
        }
        public func getBuilder() -> VectorTile.Tile.Builder {
            return classBuilder() as! VectorTile.Tile.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return VectorTile.Tile.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return VectorTile.Tile.Builder()
        }
        public func toBuilder() throws -> VectorTile.Tile.Builder {
            return try VectorTile.Tile.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:VectorTile.Tile) throws -> VectorTile.Tile.Builder {
            return try VectorTile.Tile.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !layers.isEmpty {
                var jsonArrayLayers:Array<Dictionary<String,Any>> = []
                for oneValueLayers in layers {
                    let ecodedMessageLayers = try oneValueLayers.encode()
                    jsonArrayLayers.append(ecodedMessageLayers)
                }
                jsonMap["layers"] = jsonArrayLayers
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> VectorTile.Tile {
            return try VectorTile.Tile.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> VectorTile.Tile {
            return try VectorTile.Tile.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var layersElementIndex:Int = 0
            for oneElementLayers in layers {
                output += "\(indent) layers[\(layersElementIndex)] {\n"
                output += try oneElementLayers.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                layersElementIndex += 1
            }
            output += try getExtensionDescription(startInclusive:16, endExclusive:8192, indent:indent)
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementLayers in layers {
                    hashCode = (hashCode &* 31) &+ oneElementLayers.hashValue
                }
                hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(startInclusive: 16, endExclusive:8192))
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "VectorTile.Tile"
        }
        override public func className() -> String {
            return "VectorTile.Tile"
        }
        //Meta information declaration end

        final public class Builder : ExtendableMessageBuilder {
            fileprivate var builderResult:VectorTile.Tile = VectorTile.Tile()
            public func getMessage() -> VectorTile.Tile {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var layers:Array<VectorTile.Tile.Layer> {
                get {
                    return builderResult.layers
                }
                set (value) {
                    builderResult.layers = value
                }
            }
            @discardableResult
            public func setLayers(_ value:Array<VectorTile.Tile.Layer>) -> VectorTile.Tile.Builder {
                self.layers = value
                return self
            }
            @discardableResult
            public func clearLayers() -> VectorTile.Tile.Builder {
                builderResult.layers.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:ExtendableMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> VectorTile.Tile.Builder {
                builderResult = VectorTile.Tile()
                return self
            }
            override public func clone() throws -> VectorTile.Tile.Builder {
                return try VectorTile.Tile.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> VectorTile.Tile {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> VectorTile.Tile {
                let returnMe:VectorTile.Tile = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:VectorTile.Tile) throws -> VectorTile.Tile.Builder {
                if other == VectorTile.Tile() {
                    return self
                }
                if !other.layers.isEmpty  {
                     builderResult.layers += other.layers
                }
                try mergeExtensionFields(other: other)
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> VectorTile.Tile.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> VectorTile.Tile.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 26:
                        let subBuilder = VectorTile.Tile.Layer.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        layers.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> VectorTile.Tile.Builder {
                let resultDecodedBuilder = VectorTile.Tile.Builder()
                if let jsonValueLayers = jsonMap["layers"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayLayers:Array<VectorTile.Tile.Layer> = []
                    for oneValueLayers in jsonValueLayers {
                        let messageFromStringLayers = try VectorTile.Tile.Layer.Builder.decodeToBuilder(jsonMap:oneValueLayers).build()

                        jsonArrayLayers.append(messageFromStringLayers)
                    }
                    resultDecodedBuilder.layers = jsonArrayLayers
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> VectorTile.Tile.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try VectorTile.Tile.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

}
extension VectorTile.Tile: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<VectorTile.Tile> {
        var mergedArray = Array<VectorTile.Tile>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> VectorTile.Tile? {
        return try VectorTile.Tile.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> VectorTile.Tile {
        return try VectorTile.Tile.Builder().mergeFrom(data: data, extensionRegistry:VectorTile.VectorTileRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> VectorTile.Tile {
        return try VectorTile.Tile.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> VectorTile.Tile {
        return try VectorTile.Tile.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> VectorTile.Tile {
        return try VectorTile.Tile.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> VectorTile.Tile {
        return try VectorTile.Tile.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> VectorTile.Tile {
        return try VectorTile.Tile.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "layers": return self.layers
        default: return nil
        }
    }
}
extension VectorTile.Tile.Value: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<VectorTile.Tile.Value> {
        var mergedArray = Array<VectorTile.Tile.Value>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> VectorTile.Tile.Value? {
        return try VectorTile.Tile.Value.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> VectorTile.Tile.Value {
        return try VectorTile.Tile.Value.Builder().mergeFrom(data: data, extensionRegistry:VectorTile.VectorTileRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> VectorTile.Tile.Value {
        return try VectorTile.Tile.Value.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> VectorTile.Tile.Value {
        return try VectorTile.Tile.Value.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> VectorTile.Tile.Value {
        return try VectorTile.Tile.Value.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> VectorTile.Tile.Value {
        return try VectorTile.Tile.Value.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> VectorTile.Tile.Value {
        return try VectorTile.Tile.Value.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "stringValue": return self.stringValue
        case "floatValue": return self.floatValue
        case "doubleValue": return self.doubleValue
        case "intValue": return self.intValue
        case "uintValue": return self.uintValue
        case "sintValue": return self.sintValue
        case "boolValue": return self.boolValue
        default: return nil
        }
    }
}
extension VectorTile.Tile.Feature: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<VectorTile.Tile.Feature> {
        var mergedArray = Array<VectorTile.Tile.Feature>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> VectorTile.Tile.Feature? {
        return try VectorTile.Tile.Feature.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> VectorTile.Tile.Feature {
        return try VectorTile.Tile.Feature.Builder().mergeFrom(data: data, extensionRegistry:VectorTile.VectorTileRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> VectorTile.Tile.Feature {
        return try VectorTile.Tile.Feature.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> VectorTile.Tile.Feature {
        return try VectorTile.Tile.Feature.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> VectorTile.Tile.Feature {
        return try VectorTile.Tile.Feature.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> VectorTile.Tile.Feature {
        return try VectorTile.Tile.Feature.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> VectorTile.Tile.Feature {
        return try VectorTile.Tile.Feature.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "id": return self.id
        case "tags": return self.tags
        case "type": return self.type
        case "geometry": return self.geometry
        default: return nil
        }
    }
}
extension VectorTile.Tile.Layer: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<VectorTile.Tile.Layer> {
        var mergedArray = Array<VectorTile.Tile.Layer>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> VectorTile.Tile.Layer? {
        return try VectorTile.Tile.Layer.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> VectorTile.Tile.Layer {
        return try VectorTile.Tile.Layer.Builder().mergeFrom(data: data, extensionRegistry:VectorTile.VectorTileRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> VectorTile.Tile.Layer {
        return try VectorTile.Tile.Layer.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> VectorTile.Tile.Layer {
        return try VectorTile.Tile.Layer.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> VectorTile.Tile.Layer {
        return try VectorTile.Tile.Layer.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> VectorTile.Tile.Layer {
        return try VectorTile.Tile.Layer.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> VectorTile.Tile.Layer {
        return try VectorTile.Tile.Layer.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "version": return self.version
        case "name": return self.name
        case "features": return self.features
        case "keys": return self.keys
        case "values": return self.values
        case "extent": return self.extent
        default: return nil
        }
    }
}
extension VectorTile.Tile.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = VectorTile.Tile
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "layers": return self.layers
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "layers":
                guard let newSubscriptValue = newSubscriptValue as? Array<VectorTile.Tile.Layer> else {
                    return
                }
                self.layers = newSubscriptValue
            default: return
            }
        }
    }
}
extension VectorTile.Tile.Value.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = VectorTile.Tile.Value
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "stringValue": return self.stringValue
            case "floatValue": return self.floatValue
            case "doubleValue": return self.doubleValue
            case "intValue": return self.intValue
            case "uintValue": return self.uintValue
            case "sintValue": return self.sintValue
            case "boolValue": return self.boolValue
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "stringValue":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.stringValue = newSubscriptValue
            case "floatValue":
                guard let newSubscriptValue = newSubscriptValue as? Float else {
                    return
                }
                self.floatValue = newSubscriptValue
            case "doubleValue":
                guard let newSubscriptValue = newSubscriptValue as? Double else {
                    return
                }
                self.doubleValue = newSubscriptValue
            case "intValue":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.intValue = newSubscriptValue
            case "uintValue":
                guard let newSubscriptValue = newSubscriptValue as? UInt64 else {
                    return
                }
                self.uintValue = newSubscriptValue
            case "sintValue":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.sintValue = newSubscriptValue
            case "boolValue":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.boolValue = newSubscriptValue
            default: return
            }
        }
    }
}
extension VectorTile.Tile.Feature.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = VectorTile.Tile.Feature
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "id": return self.id
            case "tags": return self.tags
            case "type": return self.type
            case "geometry": return self.geometry
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "id":
                guard let newSubscriptValue = newSubscriptValue as? UInt64 else {
                    return
                }
                self.id = newSubscriptValue
            case "tags":
                guard let newSubscriptValue = newSubscriptValue as? Array<UInt32> else {
                    return
                }
                self.tags = newSubscriptValue
            case "type":
                guard let newSubscriptValue = newSubscriptValue as? VectorTile.Tile.GeomType else {
                    return
                }
                self.type = newSubscriptValue
            case "geometry":
                guard let newSubscriptValue = newSubscriptValue as? Array<UInt32> else {
                    return
                }
                self.geometry = newSubscriptValue
            default: return
            }
        }
    }
}
extension VectorTile.Tile.Layer.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = VectorTile.Tile.Layer
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "version": return self.version
            case "name": return self.name
            case "features": return self.features
            case "keys": return self.keys
            case "values": return self.values
            case "extent": return self.extent
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "version":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.version = newSubscriptValue
            case "name":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.name = newSubscriptValue
            case "features":
                guard let newSubscriptValue = newSubscriptValue as? Array<VectorTile.Tile.Feature> else {
                    return
                }
                self.features = newSubscriptValue
            case "keys":
                guard let newSubscriptValue = newSubscriptValue as? Array<String> else {
                    return
                }
                self.keys = newSubscriptValue
            case "values":
                guard let newSubscriptValue = newSubscriptValue as? Array<VectorTile.Tile.Value> else {
                    return
                }
                self.values = newSubscriptValue
            case "extent":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.extent = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)
